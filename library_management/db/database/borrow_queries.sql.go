// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: borrow_queries.sql

package database

import (
	"context"
	"time"
)

const bookBorrow = `-- name: BookBorrow :many
INSERT INTO borrow (borrow_date,return_date,user_id,book_id,status) 
VALUES ($1, $2, $3,$4,$5) RETURNING id, user_id, book_id, status, borrow_date, return_date
`

type BookBorrowParams struct {
	BorrowDate time.Time `json:"borrow_date"`
	ReturnDate time.Time `json:"return_date"`
	UserID     int32     `json:"user_id"`
	BookID     int32     `json:"book_id"`
	Status     string    `json:"status"`
}

func (q *Queries) BookBorrow(ctx context.Context, arg BookBorrowParams) ([]Borrow, error) {
	rows, err := q.db.QueryContext(ctx, bookBorrow,
		arg.BorrowDate,
		arg.ReturnDate,
		arg.UserID,
		arg.BookID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Borrow
	for rows.Next() {
		var i Borrow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BookID,
			&i.Status,
			&i.BorrowDate,
			&i.ReturnDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrowHistory = `-- name: GetBorrowHistory :many
SELECT
    bb.id AS borrow_id,
    bb.borrow_date,
    bb.return_date,
    bb.status,
    u.username AS user_username,
    b.title AS book_name
FROM
    borrow bb
INNER JOIN
    users u ON bb.user_id = u.id
INNER JOIN
    books b ON bb.book_id = b.id
`

type GetBorrowHistoryRow struct {
	BorrowID     int32     `json:"borrow_id"`
	BorrowDate   time.Time `json:"borrow_date"`
	ReturnDate   time.Time `json:"return_date"`
	Status       string    `json:"status"`
	UserUsername string    `json:"user_username"`
	BookName     string    `json:"book_name"`
}

func (q *Queries) GetBorrowHistory(ctx context.Context) ([]GetBorrowHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getBorrowHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBorrowHistoryRow
	for rows.Next() {
		var i GetBorrowHistoryRow
		if err := rows.Scan(
			&i.BorrowID,
			&i.BorrowDate,
			&i.ReturnDate,
			&i.Status,
			&i.UserUsername,
			&i.BookName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrows = `-- name: GetBorrows :many
SELECT
    bb.id AS borrow_id,
    bb.borrow_date,
    bb.return_date,
    bb.status,
    u.username AS user_username,
    b.title AS book_name
FROM
    borrow bb
INNER JOIN
    users u ON bb.user_id = u.id
INNER JOIN
    books b ON bb.book_id = b.id
WHERE status= $1 OR bb.return_date < CURRENT_TIMESTAMP
`

type GetBorrowsRow struct {
	BorrowID     int32     `json:"borrow_id"`
	BorrowDate   time.Time `json:"borrow_date"`
	ReturnDate   time.Time `json:"return_date"`
	Status       string    `json:"status"`
	UserUsername string    `json:"user_username"`
	BookName     string    `json:"book_name"`
}

func (q *Queries) GetBorrows(ctx context.Context, status string) ([]GetBorrowsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBorrows, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBorrowsRow
	for rows.Next() {
		var i GetBorrowsRow
		if err := rows.Scan(
			&i.BorrowID,
			&i.BorrowDate,
			&i.ReturnDate,
			&i.Status,
			&i.UserUsername,
			&i.BookName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnbook = `-- name: Returnbook :exec
UPDATE borrow
  set status = $2
WHERE id = $1
`

type ReturnbookParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) Returnbook(ctx context.Context, arg ReturnbookParams) error {
	_, err := q.db.ExecContext(ctx, returnbook, arg.ID, arg.Status)
	return err
}
